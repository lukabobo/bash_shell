# Chapter 9: Chuyển hướng (Redirection)

## 9.1. Chuyển hướng output tiêu chuẩn

Chuyển hướng đầu ra tiêu chuẩn (STDOUT) của lệnh hiện tại thành một tệp hoặc một bộ mô tả khác.

Ví dụ:

    ls >file.txt
    > file.txt ls

    [root@localhost ~]# ls
    anaconda-ks.cfg  file1  file2  file3
    [root@localhost ~]# ls >file.txt
    [root@localhost ~]# cat file.txt
    anaconda-ks.cfg
    file1
    file2
    file3
    file.txt
    [root@localhost ~]# > file.txt ls
    [root@localhost ~]# cat file.txt
    anaconda-ks.cfg
    file1
    file2
    file3
    file.txt
    [root@localhost ~]#

Nếu không tồn tại hoặc không có giá trị nào được chỉ định. Lệnh sẽ in ra lỗi và STDOUT sẽ không có dữ liệu.

    [root@localhost ~]# ls 1 >file.txt
    ls: cannot access 1: No such file or directory
    [root@localhost ~]#

Lưu ý: chuyển hướng được tạo bởi shell thực thi chứ không phải thực hiện bằng lệnh thực thi, do đó nó sẽ hoàn thành trước khi thực thi lệnh.

## 9.2. Nối và cắt

### Cắt `>`

    [root@localhost ~]# echo "dong dau tien" > /tmp/lines
    [root@localhost ~]# echo "dong thu hai" > /tmp/lines
    [root@localhost ~]# cat /tmp/lines
    dong thu hai
    [root@localhost ~]#

Cắt sẽ loại bỏ nội dung đã có của file và thay vào đó là nội dung được ghi gần nhất

### Nối `>>`

    [root@localhost ~]# echo "dong 1" > /tmp/lines
    [root@localhost ~]# echo "dong 2" >> /tmp/lines
    [root@localhost ~]# cat /tmp/lines
    dong 1
    dong 2
    [root@localhost ~]#

Nối sẽ thêm nội dung vào cuối tệp. Không thay thế nội dung đã có

## 9.3. Chuyển hướng STDOUT và STDERR

File mô tả như 0 và 1 là các con trỏ (pointer). Chúng ta đổi thứ file mô tả trỏ tới với việc chuyển hướng. >/dev/null có nghĩa là 1 trỏ tới /dev/null

Đầu tiên ta trỏ 1 (STDOUT) tới /dev/null rồi trỏ 2 (STDERR) tới thứ mà 1 trỏ tới.

    # STDERR is redirect to STDOUT: redirected to /dev/null,
    # effectually redirecting both STDERR and STDOUT to /dev/null
    echo 'hello' > /dev/null 2>&1

Rút gọn lại thành

    echo 'hello' &> /dev/null

## 9.4. Sử dụng named pipes

Đôi khi ta muốn output thứ gì đó bới 1 phần mềm và input nó vào 1 phần mềm khác, nhưng không thể dùng pipe tiêu chuẩn.

    ls -l | grep ".log"

Có thể viêt vào một file tạm

    [root@localhost ~]# touch temp.txt
    [root@localhost ~]# ls -l > temp.txt
    [root@localhost ~]# grep "file" < temp.txt
    -rw-r--r--. 1 root root    2 Sep 11 16:44 file1
    -rw-r--r--. 1 root root    2 Sep 11 16:44 file2
    -rw-r--r--. 1 root root    2 Sep 11 16:44 file3
    -rw-r--r--. 1 root root    0 Sep 13 11:43 file.txt
    [root@localhost ~]#

Điều này tốt cho hầu hết các ứng dụng, tuy nhiên, sẽ không ai biết temp.txt dùng để làm gì và ai đó có thể xóa nó nếu nó chứa output của lệnh ls. Đây là lúc named pipe thể hiện.

    mkfifo myPipe
    ls -l > myPipe &
    grep "file" < myPipe &

myPipe là một pipe, không phải file nên ta không thể dùng lệnh cat để xem nội dung của nó

    ls -alh 
    prw-r--r--.  1 root root    0 Sep 14 15:15 myPipe

Chữ p ở phần permission là viết tắt cho pipe.

Bây giờ thử làm 1 thứ hay ho.

Mở 1 terminal và tạo 1 file pipe

    mkfifo myPype

Cho nó 1 mội dung

    echo "Hello" > myPipe

Mở 1 terminal khác và xem nội dung file vừa rồi

    cat < myPipe

Ta sẽ thấy output là Hello

Bây giờ làm ngược lại.

Mở 1 terminal và chạy lệnh `cat < myPipe`, sau đó mở 1 terminal khác và thêm nội dung vào cho nó `echo "Hello" > myPipe`. Quay lại terminal đầu tiên sẽ thấy nó sẽ in ra output là "Hello"

Lý do là vì một chương trình sẽ chờ đến khi có gì đó được cho vào pipe trước khi tắt, bởi vì nó biết nó sẽ nhận được cái gì đó.

Named pipe hữu ích để chuyển dữ liệu giữa các terminal hay các chương trình.

Một vài ví dụ, chạy trên cùng một terminal, cùng shell

    $ { ls -l && cat file3; } > mypipe &
    $ cat < mypipe
    # Output: In ls -l dữ liệu và sau đó in nội dung file3 ra màn hình

    $ ls -l > mypipe &
    $ cat file3 >mypipe &
    $ cat < mypipe
    #Output: in ra màn hình nội dung mypipe.

    $ { pipedata=$(<mypipe) && echo "$pipedata"; } &
    $ ls > mypipe
    # Output: in output của ls trực tiếp ra màn hình

    $ export pipedata
    $ pipedata=$(< mypipe) &
    $ ls -l *.sh > mypipe
    $ echo "$pipedata"
    #Output : In ra chính xác nội dung của mypipe

## 9.5. Chuyển hướng tới địa chỉ mạng

Bash coi một số đường dẫn là đặc biệt và có thể thực hiện một só giao tiếp mạng bằng cách viết vào /dev/{udp|tcp}/host/port. Bash không thể thiết lập một máy chủ để lắng nghe, nhưng có thể bắt đầu kết nối và đối với TCP thì có thể đọc được kết quả. 

    exec 3</dev/tcp/www.google.com/80
    printf 'GET / HTTP/1.0\r\n\r\n' >&3
    cat <&3

Nội dung của trang mặc định của www.google.com sẽ được in ra stdout

## 9.6. In thông điệp lỗi vào stderr

Thông báo lỗi thường được bao gồm trong một script cho mục đích gỡ lỗi hoặc để cung cấp cho trải nghiệm người dùng tốt

    cmd || echo 'cmd failed'

Ví dụ trên không phải cách thông dụng. Thông điệp lỗi nên vào stderr

    cmd || echo 'cmd failed' > /dev/stderr

Ví dụ khác. Thông điệp thành công sẽ in ra stdout còn thông điệp lỗi sẽ in ra stderr

    if cmd; then
    echo 'success'
    else
    echo 'cmd failed' >/dev/stderr
    fi

Cách tốt hơn

    err(){
    echo "E: $*" >>/dev/stderr
    }

    [root@localhost ~]# err "thong diep loi"
    E: thong diep loi
    [root@localhost ~]#

## 9.7. Chuyển hướng nhiều lệnh đến một file

Đặt các lệnh vào trong dấu ngoặc nhọn

    {
    echo "Nội dung thư mục home"
    ls ~
    } > output_home.txt

## 9.8. Chuyển hướng STDIN

Dấu `<` đọc từ đối số bên phải của nó và viết vào đối số bên trái của nó

Để viết một file vào STDIN, ta nên đọc /tmp/a_file và viết vào STDIN. Ví dụ: `0</tmp/a_file`

Lưu ý: Bộ mô tả tệp nội bộ được mặc định thành 0 (STDIN) cho <

    [root@localhost ~]# echo "b" > /tmp/list.txt
    [root@localhost ~]# echo "c" >> /tmp/list.txt
    [root@localhost ~]# echo "a" >> /tmp/list.txt
    [root@localhost ~]# sort < /tmp/list.txt
    a
    b
    c
    [root@localhost ~]#

## 9.9. Chuyển hướng STDERR

2 là STDERR

    echo_to_stderr 2>/dev/null

echo_to_stderr là lệnh viết "stderr" vào STDERR

    echo_to_stderr () {
    echo stderr >&2
    }

    [root@localhost ~]# echo_to_stderr
    stderr

## 9.10. Giải thích STDIN, STDOUT, STDERR 

Lệnh có 1 input (STDIN) và 2 loại output là output tiêu chuẩn (STDOUT) và lỗi tiêu chuẩn (STDERR)

Ví dụ:

### STDIN

    [root@localhost ~]# read
    viet vai dong vao day
    [root@localhost ~]#

Input tiêu chuẩn được dùng để cung cấp input và một chương trình. Ở đây dùng lệnh read để đọc 1 dòng vào STDIN

### STDOUT

    [root@localhost ~]# ls /opt/
    a.sh         file1.gz  file3.gz       hello.txt.gz  log.txt
    combined.gz  file2.gz  greetings.txt  howdy.txt.gz
    [root@localhost ~]#

Output tiêu chuẩn dùng cho output bình thường từ một lệnh. Ví dụ lệnh ls in ra danh sách file gửi tới STDOUT

### STDERR

    [root@localhost ~]# ls file
    ls: cannot access file: No such file or directory
    [root@localhost ~]#

Lỗi tiêu chuẩn dùng cho các thông điệp lỗi. Vì thông điệp này không phải là danh sách các file, nên nó được gửi tới STDERR.

STDIN, STDOUT, STDERR là 3 dòng tiêu chuẩn (standard stream). Chúng được xác định tới shell bới một số hơn là một cái tên:

0 = vào tiêu chuẩn

1 = ra tiêu chuẩn

2 = lỗi tiêu chuẩn

Mặc định, STDIN gắn liền với bàn phím. Còn STDOUT, STDERR xuất hiện trong terminal. Tuy nhiên, ta có thể chuyển hướng STDOUT hoặc STDERR tới bất cứ đâu ta cần. Ví dụ, ta chỉ cần đầu ra tiêu chuẩn còn tất cả lỗi tiêu chuẩn in ra sẽ bị suspend. Đây là khi ta cần bộ mô tả 1 và 2

### Chuyển hướng STDERR tới `/dev/null`

    ls file 2 > /dev/null

Trong trường hợp này, nếu có bất ký STDERR nào, nó sẽ được chuyển hướng tới `/dev/null` (file đặc biệt, bỏ qua bất cứ thứ gì đặt vào bên trong nó) và chúng ta sẽ không nhận một lỗi tiêu chuẩn nào trên shell.

